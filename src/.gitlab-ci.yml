# SpringBoot 앱용 gitlab-ci 파이프라인
# - 머지 요청 시 테스트, 태그 생성 시 도커 이미지 빌드하는 파이프라인

# 시나리오
# Stage 1: test
#   master, develop 브랜치에 대해 Merge Request 시 gradle test 진행하는 스테이지
#   1-1 test-gradle job
#     * gradle test 진행. 실패 시 Merge 버튼 비활성화 (실패할때도 Merge 할 수 있도록 프로젝트 Setting에서 설정 변경 가능)
#     * gradle test 결과 리포트 깃랩 MR 화면 및 Job 상세 화면에서 확인 가능
#     * gradle jacoco 플러그인으로 코드 커버리지 체크
#   1-2 visualize-coverage job
#     * jacoco 결과 리포트를 cobertura 플러그인으로 가공해서 MR Changes 화면에서 코드 커버리지 확인할 수 있도록 추가
# Stage 2: analyze
#   master 브랜치에 Merge 커밋이 올라오면 정적 코드 분석 진행하는 스테이지
#   2.1 analyze-code
#     * Sonarcube 등을 이용해서 정적 코드 분석 진행
# Stage 3: package
#   배포를 위해 도커 이미지를 생성하고, harbor 저장소에 푸시하는 스테이지
#   3-1 build-docker
#     * gradle bootBuildImage 명령어를 통해 스프링부트앱을 도커 이미지로 패키징
#     * harbor 도커 이미지 저장소로 패키징된 이미지 푸시
# Stage 4: deploy
#   Continuous Delivery 를 위해 GitOps 저장소에 변경사항 커밋하는 스테이지
#   4-1 deploy-gitops
#     * 쿠버네티스 리소스가 저장된 GitOps 저장소 클론
#     * 3-1에서 생성한 도커 이미지 버전 정보를 쿠버네티스 리소스(yaml 파일)에 업데이트하여 커밋
#     * 원격 GitOps 저장소에 푸시

# CI job 별로 별도 명시한 이미지가 없을 때 사용할 디폴트 이미지
#  - docker executor 로 설치된 Gitlab-runner는 Job을 실행하기 위해서 도커 컨테이너를 생성하며 이 컨테이너를 실행하기 위한 이미지를 작성함
#  - 아래 docker:{version} 이미지는 alpine 리눅스 위에 도커:{version} 만 설치된 공식 이미지임
#  - image: ubuntu:19.04   등을 사용해서 우분투 이미지를 디폴트 이미지로 사용해도 됨
# 각 팀에서 판단해서 디폴트 이미지를 정해서 작성하면 되며
#  - job 별로 사용할 이미지를 각각 명시하는걸 추천
#  - 모든 job 에서 같은 이미지를 사용한다면 디폴트 이미지만 명시해주면 job 에 이미지를 작성하지 않아도 디폴트 이미지가 사용됨
image: docker:19.03.12

stages:
  - test
  - analysis
  - package
  - deploy

variables:
  HARBOR_URL: 'harbor.wapl.ai'
  DOCKER_PROJECT: 'wapl-dev'
  GITOPS_REPOSITORY: ''

# gitlab-ci "Job" 정의
test-gradle:
  # "gradle-test" job 이 속해있는 stage
  stage: test

  # Job을 실행할 docker image 작성
  # - docker hub에 올라간 공식 이미지를 사용해도 되고, 개인 도커 허브에 public 으로 올린 이미지를 사용해도 됨
  # - 아래 예에서는 gradle test 를 실행하기 위해 gradle:7.4과 openjdk11 이 포함된 공식 이미지를 베이스로 사용했음
  image: gradle:7.4-jdk11
  rules:
    # 마스터 브랜치나 develop* 브랜치에 머지 리퀘스트가 올라올 때
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && ($CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_DEFAULT_BRANCH || $CI_MERGE_REQUEST_TARGET_BRANCH_NAME =~ /^develop.*$/ )
    #- if: $CI_PIPELINE_SOURCE ==  "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "samsung-etech"
    # 마스터 브랜치에 커밋이 올라올 때
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  script:
    - echo "If project is built, run test code"
    - ./gradlew --build-cache --gradle-user-home cache/ test

    # jacoco 리포트가 존재하면 coverage 작성
    - |-
      if [ -f build/reports/jacoco/test/html/index.html ]; then
        cat build/reports/jacoco/test/html/index.html | grep -o 'Total[^%]*%' | sed 's/<.*>/ /; s/Total/Jacoco Coverage Total:/'
      fi
  coverage: /Total.*?([0-9]{1,3})%/
  cache:
    key: gradle-cache-${CI_PROJECT_NAME} # gradle 캐시를 저장하기 위한 key
    paths:
      # 캐시 경로는 project 경로를 기준으로 상대경로를 작성하면 됨.
      # 디폴트 gradle 캐시 경로는 ${HOME}/.cache 인데 gitlab-runner는 project 하위 경로가 아닌 것들은 캐싱하지 못함
      # --gradle-user-home cache/ 옵션을 통해서 project 하위의 cache 폴더를 gradle 캐시 경로로 사용
      - cache/wrapper
      - cache/caches
  artifacts:
    reports:
      junit: build/test-results/test/**/TEST-*.xml  # unit test report
    paths:
      - build/reports/jacoco/  # jacoco code coverage report
  tags:
    - pl2-2

# MR > Change 화면에서 코드 커버리지 확인 가능하도록 표시하는 플러그인
visualize-coverage:
  stage: test
  image: registry.gitlab.com/haynes/jacoco2cobertura:1.0.7
  dependencies:
    - test-gradle
